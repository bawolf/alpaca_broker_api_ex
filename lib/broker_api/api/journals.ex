# NOTE: This file is auto generated by OpenAPI Generator 7.6.0 (https://openapi-generator.tech).
# Do not edit this file manually.

defmodule BrokerAPI.Api.Journals do
  @moduledoc """
  API calls for all endpoints tagged `Journals`.
  """

  alias BrokerAPI.Connection
  import BrokerAPI.RequestBuilder

  @doc """
  Create a Batch Journal Transaction (One-to-Many)
  You can create a batch of journal requests by using this endpoint. This is enabled on JNLC type Journals for now only.  Every single request must be valid for the entire batch operation to succeed.  In the case of a successful request, the response will contain an array of journal objects with an extra attribute error_message in the case when a specific account fails to receive a journal.

  ### Parameters

  - `connection` (BrokerAPI.Connection): Connection to server
  - `batch_journal_request` (BatchJournalRequest): 
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, [%BatchJournalResponse{}, ...]}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec create_batch_journal(Tesla.Env.client, BrokerAPI.Model.BatchJournalRequest.t, keyword()) :: {:ok, list(BrokerAPI.Model.BatchJournalResponse.t)} | {:error, Tesla.Env.t}
  def create_batch_journal(connection, batch_journal_request, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/v1/journals/batch")
      |> add_param(:body, :body, batch_journal_request)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, BrokerAPI.Model.BatchJournalResponse}
    ])
  end

  @doc """
  Create a Journal.
  A journal can be JNLC (move cash) or JNLS (move shares), dictated by `entry_type`. Generally, journal requests are subject to approval and starts from the `pending` status. The status changes are propagated through the Event API. Under certain conditions agreed for the partner, such journal transactions that meet the criteria are executed right away. 

  ### Parameters

  - `connection` (BrokerAPI.Connection): Connection to server
  - `create_journal_request` (CreateJournalRequest): 
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, BrokerAPI.Model.Journal.t}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec create_journal(Tesla.Env.client, BrokerAPI.Model.CreateJournalRequest.t, keyword()) :: {:ok, BrokerAPI.Model.Journal.t} | {:ok, String.t} | {:error, Tesla.Env.t}
  def create_journal(connection, create_journal_request, _opts \\ []) do
    request =
      %{}
      |> method(:post)
      |> url("/v1/journals")
      |> add_param(:body, :body, create_journal_request)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, BrokerAPI.Model.Journal},
      {400, false},
      {403, false},
      {404, false}
    ])
  end

  @doc """
  Cancel a pending journal.
  You can only delete a journal if the journal is still in a pending state, if a journal is executed you will not be able to delete. The alternative is to create a mirror journal entry to reverse the flow of funds.

  ### Parameters

  - `connection` (BrokerAPI.Connection): Connection to server
  - `journal_id` (String.t): 
  - `opts` (keyword): Optional parameters

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec delete_journal_by_id(Tesla.Env.client, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def delete_journal_by_id(connection, journal_id, _opts \\ []) do
    request =
      %{}
      |> method(:delete)
      |> url("/v1/journals/#{journal_id}")
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {204, false},
      {404, false},
      {422, false}
    ])
  end

  @doc """
  Return a list of requested journals.
  Returns an array of journal objects.

  ### Parameters

  - `connection` (BrokerAPI.Connection): Connection to server
  - `opts` (keyword): Optional parameters
    - `:after` (Date.t): By journal creation date. Format: 2020-01-01
    - `:before` (Date.t): By journal creation date. Format: 2020-01-01
    - `:status` (String.t): See the JournalStatus model for more info
    - `:entry_type` (String.t): JNLC or JNLS
    - `:to_account` (String.t): The account id that received the journal
    - `:from_account` (String.t): The account id that initiated the journal

  ### Returns

  - `{:ok, [%Journal{}, ...]}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec get_all_journals(Tesla.Env.client, keyword()) :: {:ok, list(BrokerAPI.Model.Journal.t)} | {:error, Tesla.Env.t}
  def get_all_journals(connection, opts \\ []) do
    optional_params = %{
      :after => :query,
      :before => :query,
      :status => :query,
      :entry_type => :query,
      :to_account => :query,
      :from_account => :query
    }

    request =
      %{}
      |> method(:get)
      |> url("/v1/journals")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, BrokerAPI.Model.Journal}
    ])
  end

  @doc """
  Subscribe to journal events (SSE).
  The Events API provides event push as well as historical queries via SSE (server sent events).  You can listen to journal status updates as they get processed by our backoffice.  Historical events are streamed immediately if queried, and updates are pushed as events occur.  Query Params Rules: - `since` required if `until` specified - `since_id` required if `until_id` specified - `since` and `since_id` canâ€™t be used at the same time Behavior: - if `since` or `since_id` not specified this will not return any historic data - if `until` or `until_id` reached stream will end (status 200)  ---  Note for people using the clients generated from this OAS spec. Currently OAS-3 doesn't have full support for representing SSE style responses from an API, so if you are using a generated client and don't specify a `since` and `until` there is a good chance the generated clients will hang waiting for the response to end.  If you require the streaming capabilities we recommend not using the generated clients for this specific usecase until the OAS-3 standards come to a consensus on how to represent this correcting in OAS-3.

  ### Parameters

  - `connection` (BrokerAPI.Connection): Connection to server
  - `opts` (keyword): Optional parameters
    - `:since` (DateTime.t): Format: YYYY-MM-DD
    - `:until` (DateTime.t): Format: YYYY-MM-DD
    - `:since_id` (integer()): 
    - `:until_id` (integer()): 

  ### Returns

  - `{:ok, [%JournalStatusEvent{}, ...]}` on success
  - `{:error, Tesla.Env.t}` on failure
  """
  @spec subscribe_to_journal_status_sse(Tesla.Env.client, keyword()) :: {:ok, list(BrokerAPI.Model.JournalStatusEvent.t)} | {:error, Tesla.Env.t}
  def subscribe_to_journal_status_sse(connection, opts \\ []) do
    optional_params = %{
      :since => :query,
      :until => :query,
      :since_id => :query,
      :until_id => :query
    }

    request =
      %{}
      |> method(:get)
      |> url("/v1/events/journals/status")
      |> add_optional_params(optional_params, opts)
      |> Enum.into([])

    connection
    |> Connection.request(request)
    |> evaluate_response([
      {200, BrokerAPI.Model.JournalStatusEvent}
    ])
  end
end
